---
title: "DGVM3D"
author: "Joerg Steinkamp"
date: "`r Sys.Date()`"
bibliography: bibliography.bib
output: rmarkdown::html_vignette
keep_md: true
vignette: >
  %\VignetteIndexEntry{DGVM3D}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This package renders the vegetation structure of individual and cohort based dynamic (global) vegetation models (DGVM) with gap dynamic. Here I present how to derive the required data with the model LPJ-GUESS [@smith_representation_2001; @smith_implications_2014].

## C++ code

To create the required output table a new output module needs to be registered in LPJ-GUESS. In the source code the following header and code files need to be placed in the modules subdirectory of the LPJ-GUESS source code. And they have to be added in the CMakeList.txt file at the appropriate position.

```{r engine='Rcpp', eval=FALSE}
///////////////////////////////////////////////////////////////////////////////////////
/// \file vegstructoutput.h
/// \brief Output module for patch based vegetation structure
///
/// \author Joerg Steinkamp
/// $Date: Thu Nov  3 11:15:37 CET 2016 $
///
///////////////////////////////////////////////////////////////////////////////////////
#ifndef LPJ_GUESS_VEGSTRUCT_OUTPUT_H
#define LPJ_GUESS_VEGSTRUCT_OUTPUT_H
#include "outputmodule.h"
#include "outputchannel.h"
#include "gutil.h"
namespace GuessOutput {
  class VegstructOutput : public OutputModule {
  public:
    VegstructOutput();
    ~VegstructOutput();
    // implemented functions inherited from OutputModule
    // (see documentation in OutputModule)
    void init();
    void outannual(Gridcell& gridcell);
    void outdaily(Gridcell& gridcell);
  private:
    xtring file_vegstruct;
    FILE *out_vegstruct;
  };
}
#endif
```

```{r engine='Rcpp', eval=FALSE}
///////////////////////////////////////////////////////////////////////////////////////
/// \file vegstructoutput.cpp
/// \brief Output module for patch based vegetation structure
///
/// \author Joerg Steinkamp
/// $Date: Thu Nov  3 11:15:37 CET 2016 $
///
///////////////////////////////////////////////////////////////////////////////////////
#include "config.h"
#include "vegstructoutput.h"
#include "parameters.h"
#include "guess.h"
namespace GuessOutput {
  REGISTER_OUTPUT_MODULE("vegstruct", VegstructOutput)
  VegstructOutput::VegstructOutput() {
    declare_parameter("file_vegstruct", &file_vegstruct, 300, "Detailed vegetation structure");
  }
  VegstructOutput::~VegstructOutput() {
  }
  void VegstructOutput::init() {
    if (file_vegstruct != "") {
      std::string full_path = (char*) file_vegstruct;
      out_vegstruct = fopen(full_path.c_str(), "w");
      if (out_vegstruct == NULL) {
        fail("Could not open %s for output\n"                         \
             "Close the file if it is open in another application",
             full_path.c_str());
      } else {
        dprintf("dummy\n");
        fprintf(out_vegstruct, "Lon Lat Year SID PID VID Pft Lifeform LeafType PhenType Pathway Age FPC LAI ShadeType N DBH Height Crownarea\n");
      }
    }
  }
  void VegstructOutput::outdaily(Gridcell& gridcell) {
    return;
  }
  void VegstructOutput::outannual(Gridcell& gridcell) {
    if (file_vegstruct == "")
      return;
    if (date.year >= nyear_spinup-50) {
      double lon = gridcell.get_lon();
      double lat = gridcell.get_lat();
        Gridcell::iterator gc_itr = gridcell.begin();
        while (gc_itr != gridcell.end()) {
          Stand& stand = *gc_itr;
          // Loop through Stands
          stand.firstobj();
          while (stand.isobj) {
            Patch& patch = stand.getobj();
            //Patchpft& patchpft = patch.pft[pft.id];
            Vegetation& vegetation = patch.vegetation;
            vegetation.firstobj();
            while (vegetation.isobj) {
              Individual& indiv=vegetation.getobj();
              // guess2008 - alive check added
              if (indiv.id != -1 && indiv.alive) {
                fprintf(out_vegstruct, "%7.2f %6.2f %4i ", lon, lat, date.get_calendar_year() );
                fprintf(out_vegstruct, " %i ",    stand.id);
                fprintf(out_vegstruct, " %i ",    patch.id);
                fprintf(out_vegstruct, " %i ",    indiv.id);
                fprintf(out_vegstruct, " %10s ",  (char*) indiv.pft.name);
                fprintf(out_vegstruct, " %i ",    indiv.pft.lifeform);
                fprintf(out_vegstruct, " %i ",    indiv.pft.leafphysiognomy);
                fprintf(out_vegstruct, " %i ",    indiv.pft.phenology);
                fprintf(out_vegstruct, " %i ",    indiv.pft.pathway);
                fprintf(out_vegstruct, " %4.0f ", indiv.age);
                fprintf(out_vegstruct, " %6.2f ", indiv.fpc);
                fprintf(out_vegstruct, " %6.2f ", indiv.lai);
                if (indiv.pft.lifeform == TREE) {
                  fprintf(out_vegstruct, " %4.1f ", indiv.pft.alphar);
                  fprintf(out_vegstruct, " %4.0f ", indiv.densindiv * patcharea);
                  fprintf(out_vegstruct, " %7.2f ", pow(indiv.height/indiv.pft.k_allom2,1.0/indiv.pft.k_allom3));
                  fprintf(out_vegstruct, " %8.2f ", indiv.height);
                  fprintf(out_vegstruct, " %8.2f ", indiv.crownarea);
                } else if (indiv.pft.lifeform == GRASS) {
                  fprintf(out_vegstruct, " %4.1f ", -1.0);
                  fprintf(out_vegstruct, " %i ",     1);
                  fprintf(out_vegstruct, " %i ",    -1);
                  fprintf(out_vegstruct, " %i ",    -1);
                  fprintf(out_vegstruct, " %i ",    -1);
                }
                fprintf(out_vegstruct, "\n");
              }
              vegetation.nextobj();
            }
            stand.nextobj();
          }
          ++gc_itr;
        //}
        //pftlist.nextobj();
      }
    }
  } // END of void VegStructOutput::outannual
} // END of namespace VegStructOutput

```

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))

## References
